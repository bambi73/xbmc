diff --git a/xbmc/BackgroundInfoLoader.cpp b/xbmc/BackgroundInfoLoader.cpp
index 3466800..220b517 100644
--- a/xbmc/BackgroundInfoLoader.cpp
+++ b/xbmc/BackgroundInfoLoader.cpp
@@ -33,6 +33,7 @@ CBackgroundInfoLoader::CBackgroundInfoLoader() : m_thread (NULL)
   m_pProgressCallback=NULL;
   m_pVecItems = NULL;
   m_bIsLoading = false;
+  m_iStartIndex = 0;
 }
 
 CBackgroundInfoLoader::~CBackgroundInfoLoader()
@@ -48,10 +49,16 @@ void CBackgroundInfoLoader::Run()
     {
       OnLoaderStart();
 
+      CLog::Log(LOGDEBUG, "### StartIndex = %d", m_iStartIndex);
+
       // Stage 1: All "fast" stuff we have already cached
-      for (vector<CFileItemPtr>::const_iterator iter = m_vecItems.begin(); iter != m_vecItems.end(); ++iter)
-      {
-        CFileItemPtr pItem = *iter;
+      for(int i = 0; m_iStartIndex - (i + 1) / 2 >= 0 || m_iStartIndex + i / 2 < (int)m_vecItems.size(); ++i) {
+        int index = (i % 2 == 0 ? m_iStartIndex + i / 2 : m_iStartIndex - (i + 1) / 2);
+
+        if(index < 0 || index >= (int)m_vecItems.size())
+          continue;
+
+        CFileItemPtr pItem = m_vecItems[index];
 
         // Ask the callback if we should abort
         if ((m_pProgressCallback && m_pProgressCallback->Abort()) || m_bStop)
@@ -69,9 +76,13 @@ void CBackgroundInfoLoader::Run()
       }
 
       // Stage 2: All "slow" stuff that we need to lookup
-      for (vector<CFileItemPtr>::const_iterator iter = m_vecItems.begin(); iter != m_vecItems.end(); ++iter)
-      {
-        CFileItemPtr pItem = *iter;
+      for(int i = 0; m_iStartIndex - (i + 1) / 2 >= 0 || m_iStartIndex + i / 2 < (int)m_vecItems.size(); ++i) {
+        int index = (i % 2 == 0 ? m_iStartIndex + i / 2 : m_iStartIndex - (i + 1) / 2);
+
+        if(index < 0 || index >= (int)m_vecItems.size())
+          continue;
+
+        CFileItemPtr pItem = m_vecItems[index];
 
         // Ask the callback if we should abort
         if ((m_pProgressCallback && m_pProgressCallback->Abort()) || m_bStop)
@@ -99,7 +110,7 @@ void CBackgroundInfoLoader::Run()
   }
 }
 
-void CBackgroundInfoLoader::Load(CFileItemList& items)
+void CBackgroundInfoLoader::Load(CFileItemList& items, int startIndex /* = 0 */)
 {
   StopThread();
 
@@ -111,6 +122,11 @@ void CBackgroundInfoLoader::Load(CFileItemList& items)
   for (int nItem=0; nItem < items.Size(); nItem++)
     m_vecItems.push_back(items[nItem]);
 
+  m_iStartIndex = startIndex;
+
+  if(m_iStartIndex < 0 || m_iStartIndex >= (int)m_vecItems.size())
+    m_iStartIndex = 0;
+
   m_pVecItems = &items;
   m_bStop = false;
   m_bIsLoading = true;
diff --git a/xbmc/BackgroundInfoLoader.h b/xbmc/BackgroundInfoLoader.h
index 5fad3f0..9a1e37a 100644
--- a/xbmc/BackgroundInfoLoader.h
+++ b/xbmc/BackgroundInfoLoader.h
@@ -43,7 +43,7 @@ public:
   CBackgroundInfoLoader();
   virtual ~CBackgroundInfoLoader();
 
-  void Load(CFileItemList& items);
+  void Load(CFileItemList& items, int startIndex = 0);
   bool IsLoading();
   virtual void Run();
   void SetObserver(IBackgroundLoaderObserver* pObserver);
@@ -63,6 +63,8 @@ protected:
   std::vector<CFileItemPtr> m_vecItems; // FileItemList would delete the items and we only want to keep a reference.
   CCriticalSection m_lock;
 
+  int m_iStartIndex;
+
   volatile bool m_bIsLoading;
   volatile bool m_bStop;
   CThread *m_thread;
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index eb0e4a5..330f4d4 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -299,6 +299,7 @@ CFileItem::CFileItem(const CFileItem& item): CGUIListItem()
   m_pvrRecordingInfoTag = NULL;
   m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
+  m_bIsDirty = false;
   *this = item;
 }
 
@@ -581,6 +582,7 @@ void CFileItem::Reset()
   m_pictureInfoTag=NULL;
   m_extrainfo.clear();
   m_specialSort = SortSpecialNone;
+  m_bIsDirty = false;
   ClearProperties();
   SetInvalid();
 }
@@ -1529,6 +1531,31 @@ void CFileItem::SetFromVideoInfoTag(const CVideoInfoTag &video)
   FillInMimeType(false);
 }
 
+void CFileItem::SetFromVideoInfoTagFast(const CVideoInfoTag &video, const CStdString& defaultIcon)
+{
+  if (!video.m_strTitle.empty())
+    SetLabel(video.m_strTitle);
+  if (video.m_strFileNameAndPath.empty())
+  {
+    m_strPath = video.m_strPath;
+    char endChar = m_strPath.c_str()[m_strPath.size() - 1];
+    if(endChar != '/' && endChar != '\\')
+      URIUtils::AddSlashAtEnd(m_strPath);
+    m_bIsFolder = true;
+  }
+  else
+  {
+    m_strPath = video.m_strFileNameAndPath;
+    m_bIsFolder = false;
+  }
+
+  *GetVideoInfoTag() = video;
+  if (video.m_iSeason == 0)
+    SetProperty("isspecial", "true");
+  SetIconImage(defaultIcon);
+  FillInMimeType(false);
+}
+
 void CFileItem::SetFromAlbum(const CAlbum &album)
 {
   if (!album.strAlbum.empty())
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 286bd34..48ee4a8 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -412,6 +412,7 @@ public:
    \param video video details to use and set
    */
   void SetFromVideoInfoTag(const CVideoInfoTag &video);
+  void SetFromVideoInfoTagFast(const CVideoInfoTag &video, const CStdString& defaultIcon);
   /*! \brief Sets details using the information from the CAlbum object
    Sets the album in the music info tag and uses its information to set the
    label and album-specific properties.
@@ -425,6 +426,9 @@ public:
    */
   void SetFromSong(const CSong &song);
 
+  bool IsDirty() const { return m_bIsDirty; }
+  void SetDirty(bool dirty) { m_bIsDirty = dirty; }
+
   bool m_bIsShareOrDrive;    ///< is this a root share/drive
   int m_iDriveType;     ///< If \e m_bIsShareOrDrive is \e true, use to get the share type. Types see: CMediaSource::m_iDriveType
   CDateTime m_dateTime;             ///< file creation date & time
@@ -458,6 +462,8 @@ private:
   PVR::CPVRTimerInfoTag * m_pvrTimerInfoTag;
   CPictureInfoTag* m_pictureInfoTag;
   bool m_bIsAlbum;
+
+  bool m_bIsDirty;
 };
 
 /*!
diff --git a/xbmc/filesystem/Directory.cpp b/xbmc/filesystem/Directory.cpp
index de98f21..b09e4a1 100644
--- a/xbmc/filesystem/Directory.cpp
+++ b/xbmc/filesystem/Directory.cpp
@@ -135,8 +135,10 @@ bool CDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items, c
       return false;
 
     // check our cache for this path
-    if (g_directoryCache.GetDirectory(realPath, items, (hints.flags & DIR_FLAG_READ_CACHE) == DIR_FLAG_READ_CACHE))
+    if (!(hints.flags & DIR_FLAG_BYPASS_CACHE) &&
+        g_directoryCache.GetDirectory(realPath, items, (hints.flags & DIR_FLAG_READ_CACHE) == DIR_FLAG_READ_CACHE)) {
       items.SetPath(strPath);
+    }
     else
     {
       // need to clear the cache (in case the directory fetch fails)
diff --git a/xbmc/filesystem/SmartPlaylistDirectory.cpp b/xbmc/filesystem/SmartPlaylistDirectory.cpp
index 77ad2df..4d3ab78 100644
--- a/xbmc/filesystem/SmartPlaylistDirectory.cpp
+++ b/xbmc/filesystem/SmartPlaylistDirectory.cpp
@@ -67,6 +67,8 @@ namespace XFILE
     bool success = false, success2 = false;
     std::vector<CStdString> virtualFolders;
 
+    unsigned int timeFull = XbmcThreads::SystemClockMillis();
+
     SortDescription sorting;
     sorting.limitEnd = playlist.GetLimit();
     sorting.sortBy = playlist.GetOrder();
@@ -148,7 +150,7 @@ namespace XFILE
           videoUrl.AddOption(option, xsp);
         else
           videoUrl.RemoveOption(option);
-        
+
         CDatabase::Filter dbfilter;
         success = db.GetItems(videoUrl.ToString(), items, dbfilter, sorting);
         db.Close();
@@ -309,6 +311,8 @@ namespace XFILE
       item->m_iprogramCount = i;  // hack for playlist order
     }
 
+    CLog::Log(LOGDEBUG, "%s took %d ms ", "CSmartPlaylistDirectory::GetDirectory", XbmcThreads::SystemClockMillis() - timeFull);
+
     if (playlist.GetType().Equals("mixed"))
       return success || success2;
     else if (playlist.GetType().Equals("musicvideos"))
diff --git a/xbmc/filesystem/VirtualDirectory.cpp b/xbmc/filesystem/VirtualDirectory.cpp
index 7146c6c..29346e8 100644
--- a/xbmc/filesystem/VirtualDirectory.cpp
+++ b/xbmc/filesystem/VirtualDirectory.cpp
@@ -75,6 +75,8 @@ bool CVirtualDirectory::GetDirectory(const CStdString& strPath, CFileItemList &i
 bool CVirtualDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items, bool bUseFileDirectories)
 {
   int flags = m_flags;
+  if (!(flags & DIR_FLAG_READ_CACHE))
+    flags |= DIR_FLAG_BYPASS_CACHE;
   if (!bUseFileDirectories)
     flags |= DIR_FLAG_NO_FILE_DIRS;
   if (!strPath.empty() && strPath != "files://")
diff --git a/xbmc/utils/SortUtils.cpp b/xbmc/utils/SortUtils.cpp
index 655b1dd..095fbde 100644
--- a/xbmc/utils/SortUtils.cpp
+++ b/xbmc/utils/SortUtils.cpp
@@ -27,6 +27,7 @@
 #include "utils/StdString.h"
 #include "utils/StringUtils.h"
 #include "utils/Variant.h"
+#include "utils/log.h"
 
 using namespace std;
 
@@ -707,7 +708,11 @@ void SortUtils::Sort(const SortDescription &sortDescription, SortItems& items)
 
 bool SortUtils::SortFromDataset(const SortDescription &sortDescription, MediaType mediaType, const std::auto_ptr<dbiplus::Dataset> &dataset, DatabaseResults &results)
 {
-  FieldList fields;
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+  unsigned int timePart = XbmcThreads::SystemClockMillis();
+ 	CLog::Log(LOGDEBUG, "%s started", "SortUtils::SortFromDataset");
+
+ 	FieldList fields;
   if (!DatabaseUtils::GetSelectFields(SortUtils::GetFieldsForSorting(sortDescription.sortBy), mediaType, fields))
     fields.clear();
 
@@ -721,8 +726,14 @@ bool SortUtils::SortFromDataset(const SortDescription &sortDescription, MediaTyp
     sorting.limitEnd = -1;
   }
 
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "SortUtils::SortFromDataset loading from dataset", XbmcThreads::SystemClockMillis() - timePart);
+  timePart = XbmcThreads::SystemClockMillis();
+
   Sort(sorting, results);
 
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "SortUtils::SortFromDataset sorting", XbmcThreads::SystemClockMillis() - timePart);
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "SortUtils::SortFromDataset", XbmcThreads::SystemClockMillis() - timeFull);
+
   return true;
 }
 
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index aa810d9..46c5008 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -2137,12 +2137,15 @@ int CVideoDatabase::SetDetailsForTvShow(const CStdString& strPath, const CVideoI
     }
 
     BeginTransaction();
+    bool bUpdateCache = false;
 
     if (idTvShow < 0)
       idTvShow = GetTvShowId(strPath);
 
-    if (idTvShow > -1)
+    if (idTvShow > -1) {
       DeleteDetailsForTvShow(strPath, idTvShow);
+      bUpdateCache = true;
+    }
     else
     {
       idTvShow = AddTvShow(strPath);
@@ -2193,6 +2196,11 @@ int CVideoDatabase::SetDetailsForTvShow(const CStdString& strPath, const CVideoI
     sql += PrepareSQL(" where idShow=%i", idTvShow);
     m_pDS->exec(sql.c_str());
 
+    if(bUpdateCache)
+      UpdateTvShowFileItemById(idTvShow);
+    else
+      sm_TvShowCache.DirtyAllTvShowCacheItems();
+
     CommitTransaction();
 
     return idTvShow;
@@ -2316,6 +2324,9 @@ int CVideoDatabase::SetDetailsForEpisode(const CStdString& strFilenameAndPath, c
     CStdString sql = "update episode set " + GetValueString(details, VIDEODB_ID_EPISODE_MIN, VIDEODB_ID_EPISODE_MAX, DbEpisodeOffsets);
     sql += PrepareSQL(" where idEpisode=%i", idEpisode);
     m_pDS->exec(sql.c_str());
+
+    UpdateTvShowFileItemById(idShow);
+
     CommitTransaction();
 
     return idEpisode;
@@ -2939,7 +2950,7 @@ void CVideoDatabase::DeleteTvShow(const CStdString& strPath, bool bKeepId /* = f
       CStdString strPath = m_pDS2->fv("path.strPath").get_asString();
       CStdString strFileName = m_pDS2->fv("files.strFilename").get_asString();
       ConstructPath(strFilenameAndPath, strPath, strFileName);
-      DeleteEpisode(strFilenameAndPath, m_pDS2->fv(0).get_asInt(), bKeepId);
+      DeleteEpisode(strFilenameAndPath, m_pDS2->fv(0).get_asInt(), bKeepId, bKeepId);
       m_pDS2->next();
     }
 
@@ -2961,6 +2972,7 @@ void CVideoDatabase::DeleteTvShow(const CStdString& strPath, bool bKeepId /* = f
       m_pDS->exec(strSQL.c_str());
 
       InvalidatePathHash(strPath);
+      sm_TvShowCache.ProcessAffectedTvShowFileItems(idTvShow, NULL, false, true);
    }
 
     //TODO: move this below CommitTransaction() once UPnP doesn't rely on this anymore
@@ -2988,7 +3000,8 @@ void CVideoDatabase::DeleteEpisode(int idEpisode, bool bKeepId /* = false */)
     DeleteEpisode(path, idEpisode, bKeepId);
 }
 
-void CVideoDatabase::DeleteEpisode(const CStdString& strFilenameAndPath, int idEpisode /* = -1 */, bool bKeepId /* = false */)
+void CVideoDatabase::DeleteEpisode(
+    const CStdString& strFilenameAndPath, int idEpisode /* = -1 */, bool bKeepId /* = false */, bool bUpdateCache /* = true */)
 {
   try
   {
@@ -3023,10 +3036,17 @@ void CVideoDatabase::DeleteEpisode(const CStdString& strFilenameAndPath, int idE
     // the ancilliary tables are still purged
     if (!bKeepId)
     {
+      int showId = -1;
+
       ClearBookMarksOfFile(strFilenameAndPath);
+      if(bUpdateCache)
+        showId = GetTvShowForEpisode(idEpisode);
 
       strSQL=PrepareSQL("delete from episode where idEpisode=%i", idEpisode);
       m_pDS->exec(strSQL.c_str());
+
+      if(bUpdateCache)
+        UpdateTvShowFileItemById(showId);
     }
 
   }
@@ -4513,6 +4533,9 @@ void CVideoDatabase::SetPlayCount(const CFileItem &item, int count, const CDateT
       }
       else
         ANNOUNCEMENT::CAnnouncementManager::Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnUpdate", CFileItemPtr(new CFileItem(item)));
+
+      if(item.GetVideoInfoTag()->m_type == "episode")
+        UpdateTvShowFileItemById(item.GetVideoInfoTag()->m_iIdShow);
     }
   }
   catch (...)
@@ -5976,6 +5999,8 @@ bool CVideoDatabase::GetTvShowsNav(const CStdString& strBaseDir, CFileItemList&
 
 bool CVideoDatabase::GetTvShowsByWhere(const CStdString& strBaseDir, const Filter &filter, CFileItemList& items, const SortDescription &sortDescription /* = SortDescription() */)
 {
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+
   try
   {
     movieTime = 0;
@@ -5988,13 +6013,15 @@ bool CVideoDatabase::GetTvShowsByWhere(const CStdString& strBaseDir, const Filte
     CStdString strSQL = "SELECT %s FROM tvshowview ";
     CVideoDbUrl videoUrl;
     CStdString strSQLExtra;
-    Filter extFilter = filter;
     SortDescription sorting = sortDescription;
+    Filter extFilter = filter;
+    if(sorting.sortBy == SortByNone || sorting.sortBy == SortByTitle || sorting.sortBy == SortBySortTitle)
+      extFilter.AppendOrder("c00");
     if (!BuildSQL(strBaseDir, strSQLExtra, extFilter, strSQLExtra, videoUrl, sorting))
       return false;
 
     // Apply the limiting directly here if there's no special sorting but limiting
-      if (extFilter.limit.empty() &&
+    if (extFilter.limit.empty() &&
         sorting.sortBy == SortByNone &&
         (sorting.limitStart > 0 || sorting.limitEnd > 0))
     {
@@ -6004,7 +6031,23 @@ bool CVideoDatabase::GetTvShowsByWhere(const CStdString& strBaseDir, const Filte
 
     strSQL = PrepareSQL(strSQL, !extFilter.fields.empty() ? extFilter.fields.c_str() : "*") + strSQLExtra;
 
+    CTvShowCacheItemPtr cacheTvShowCacheItemPtr;
+
+    MAPI_STRING2TVSHOWCACHEITEMPTR sqlQueryIter = sm_TvShowCache.m_sqlQuery2TvShowCacheItemPtr.find(strSQL);
+    if(sqlQueryIter != sm_TvShowCache.m_sqlQuery2TvShowCacheItemPtr.end())
+      cacheTvShowCacheItemPtr = sqlQueryIter->second;
+
+    if(cacheTvShowCacheItemPtr && !cacheTvShowCacheItemPtr->IsDirty()) {
+      CStdString originalPath = items.GetPath();
+      items.Copy(*cacheTvShowCacheItemPtr->m_fileItemListPtr);
+      items.SetPath(originalPath);
+
+      CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere", XbmcThreads::SystemClockMillis() - timeFull);
+      return true;
+    }
+
     int iRowsFound = RunQuery(strSQL);
+
     if (iRowsFound <= 0)
       return iRowsFound == 0;
 
@@ -6015,46 +6058,131 @@ bool CVideoDatabase::GetTvShowsByWhere(const CStdString& strBaseDir, const Filte
     
     DatabaseResults results;
     results.reserve(iRowsFound);
+
     if (!SortUtils::SortFromDataset(sorting, MediaTypeTvShow, m_pDS, results))
       return false;
 
+    unsigned int timeFill = 0;
+    unsigned int timeSumGetVideoTag = 0;
+    unsigned int timeSumFillFileItem = 0;
+    unsigned int timePart = XbmcThreads::SystemClockMillis();
+
+    CURL baseURL(strBaseDir);
+    CStdString baseURLMain;
+    CStdString baseURLOptions;
+
+    baseURLMain = baseURL.GetWithoutFilename();
+    baseURLMain += baseURL.GetFileName();
+
+    if(!baseURL.GetOptions().empty())
+      baseURLOptions += baseURL.GetOptions();
+    if(!baseURL.GetProtocolOptions().empty())
+      baseURLOptions += ("|" + baseURL.GetProtocolOptions());
+
+    int baseURLReserve = baseURLMain.length() + (!baseURLOptions.empty() ? baseURLOptions.length() : 0) + 8;
+
+    bool cacheInsertMode;
+    int takenFromCache = 0;
+
+    if(!cacheTvShowCacheItemPtr) {
+      cacheTvShowCacheItemPtr = CTvShowCacheItemPtr(new CTvShowCacheItem);
+      cacheTvShowCacheItemPtr->m_fileItemListPtr = CFileItemListPtr(new CFileItemList);
+      cacheTvShowCacheItemPtr->m_fileItemListPtr->Copy(items, false);
+      sm_TvShowCache.m_sqlQuery2TvShowCacheItemPtr[strSQL] = cacheTvShowCacheItemPtr;
+      cacheInsertMode = true;
+    }
+    else {
+      cacheTvShowCacheItemPtr->m_fileItemListPtr->ClearItems();
+      cacheInsertMode = false;
+    }
+
+    cacheTvShowCacheItemPtr->SetDirty(false);
+
     // get data from returned rows
     items.Reserve(results.size());
+    cacheTvShowCacheItemPtr->m_fileItemListPtr->Reserve(results.size());
+
     const query_data &data = m_pDS->get_result_set().records;
     for (DatabaseResults::const_iterator it = results.begin(); it != results.end(); it++)
     {
+      timeFill = XbmcThreads::SystemClockMillis();
+
       unsigned int targetRow = (unsigned int)it->at(FieldRow).asInteger();
       const dbiplus::sql_record* const record = data.at(targetRow);
-      
+      int idTvShow = record->at(0).get_asInt();
+
+      if(!cacheInsertMode) {
+        MAPI_INT2FILEITEMPTR tvShowId2FileItemPtrIter = cacheTvShowCacheItemPtr->m_tvShowId2FileItemPtr.find(idTvShow);
+        if(tvShowId2FileItemPtrIter != cacheTvShowCacheItemPtr->m_tvShowId2FileItemPtr.end()) {
+          CFileItemPtr cacheFileItemPtr = tvShowId2FileItemPtrIter->second;
+          if(!cacheFileItemPtr->IsDirty()) {
+            CFileItemPtr pItem(new CFileItem(*cacheFileItemPtr.get()));
+            cacheTvShowCacheItemPtr->m_fileItemListPtr->Add(cacheFileItemPtr);
+            items.Add(pItem);
+            takenFromCache++;
+
+            continue;
+          }
+        }
+      }
+
       CFileItemPtr pItem(new CFileItem());
       CVideoInfoTag movie = GetDetailsForTvShow(record, false, pItem.get());
+
+      timeSumGetVideoTag += (XbmcThreads::SystemClockMillis() - timeFill);
+      timeFill = XbmcThreads::SystemClockMillis();
+
       if ((CProfilesManager::Get().GetMasterProfile().getLockMode() == LOCK_MODE_EVERYONE ||
            g_passwordManager.bMasterUser                                     ||
            g_passwordManager.IsDatabasePathUnlocked(movie.m_strPath, *CMediaSourceSettings::Get().GetSources("video"))) &&
           (!g_advancedSettings.m_bVideoLibraryHideEmptySeries || movie.m_iEpisode > 0))
       {
-        pItem->SetFromVideoInfoTag(movie);
+        pItem->SetFromVideoInfoTagFast(movie, "DefaultFolder.png");
 
-        CVideoDbUrl itemUrl = videoUrl;
-        CStdString path = StringUtils::Format("%ld/", record->at(0).get_asInt());
-        itemUrl.AppendPath(path);
-        pItem->SetPath(itemUrl.ToString());
+        CStdString path;
+        path.reserve(baseURLReserve);
+        path = baseURLMain;
+        path += StringUtils::Format("%ld/",record->at(0).get_asInt());
+        if(!baseURLOptions.empty())
+          path += baseURLOptions;
+
+        pItem->SetPath(path);
 
         pItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, (pItem->GetVideoInfoTag()->m_playCount > 0) && (pItem->GetVideoInfoTag()->m_iEpisode > 0));
         items.Add(pItem);
+
+        CFileItemPtr cacheItemPtr(new CFileItem(*pItem));
+        cacheTvShowCacheItemPtr->m_fileItemListPtr->Add(cacheItemPtr);
+        cacheTvShowCacheItemPtr->m_tvShowId2FileItemPtr[idTvShow] = cacheItemPtr;
+        sm_TvShowCache.m_tvShowId2TvShowCacheItemPtrSet[idTvShow].insert(cacheTvShowCacheItemPtr);
       }
+
+      timeSumFillFileItem += (XbmcThreads::SystemClockMillis() - timeFill);
     }
 
-    Stack(items, VIDEODB_CONTENT_TVSHOWS, !filter.order.empty() || sorting.sortBy != SortByNone);
+    CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere processing data - GetVideoTag", timeSumGetVideoTag);
+    CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere processing data - FillFileItem", timeSumFillFileItem);
+    CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere processing data", XbmcThreads::SystemClockMillis() - timePart);
+
+    CLog::Log(LOGDEBUG, "%s %d FileItems loaded (%d from cache)", __FUNCTION__, items.Size(), takenFromCache);
+    timePart = XbmcThreads::SystemClockMillis();
+
+    // Stack(items, VIDEODB_CONTENT_TVSHOWS, !filter.order.empty() || sorting.sortBy != SortByNone);
 
     // cleanup
     m_pDS->close();
+
+    CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere", XbmcThreads::SystemClockMillis() - timeFull);
+
     return true;
   }
   catch (...)
   {
     CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
   }
+
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "CVideoDatabase::GetTvShowsByWhere", XbmcThreads::SystemClockMillis() - timeFull);
+
   return false;
 }
 
@@ -7829,6 +7957,9 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     std::vector<int> episodeIDs;
     std::vector<int> musicVideoIDs;
 
+    std::set<int> cacheUpdateTvShowIds;
+    std::set<int> cacheDeleteTvShowIds;
+
     if (!filesToTestForDelete.empty())
     {
       StringUtils::TrimRight(filesToTestForDelete, ",");
@@ -7848,6 +7979,15 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     {
       filesToDelete = "(" + StringUtils::TrimRight(filesToDelete, ",") + ")";
 
+      CLog::Log(LOGDEBUG, "%s: Loading tvshows with cleaned files", __FUNCTION__);
+      sql = "SELECT DISTINCT episode.idShow FROM episode WHERE idFile IN " + filesToDelete;
+      m_pDS->query(sql.c_str());
+      while (!m_pDS->eof()) {
+        cacheUpdateTvShowIds.insert(m_pDS->fv(0).get_asInt());
+        m_pDS->next();
+      }
+      m_pDS->close();
+
       CLog::Log(LOGDEBUG, "%s: Cleaning files table", __FUNCTION__);
       sql = "DELETE FROM files WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
@@ -7912,6 +8052,15 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
         episodesToDelete += StringUtils::Format("%i,", *it);
       episodesToDelete = "(" + StringUtils::TrimRight(episodesToDelete, ",") + ")";
 
+      CLog::Log(LOGDEBUG, "%s: Loading tvshows with cleaned episodes", __FUNCTION__);
+      sql = "SELECT DISTINCT episode.idShow FROM episode WHERE idEpisode IN " + episodesToDelete;
+      m_pDS->query(sql.c_str());
+      while (!m_pDS->eof()) {
+        cacheUpdateTvShowIds.insert(m_pDS->fv(0).get_asInt());
+        m_pDS->next();
+      }
+      m_pDS->close();
+
       CLog::Log(LOGDEBUG, "%s: Cleaning episode table", __FUNCTION__);
       sql = "DELETE FROM episode WHERE idEpisode IN " + episodesToDelete;
       m_pDS->exec(sql.c_str());
@@ -7957,6 +8106,14 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     }
 
     CLog::Log(LOGDEBUG, "%s: Cleaning tvshow table", __FUNCTION__);
+    sql = "SELECT tvshow.idShow FROM tvshow WHERE NOT EXISTS (SELECT 1 FROM tvshowlinkpath WHERE tvshowlinkpath.idShow = tvshow.idShow)";
+    m_pDS->query(sql.c_str());
+    while (!m_pDS->eof())
+    {
+      cacheDeleteTvShowIds.insert(m_pDS->fv(0).get_asInt());
+      m_pDS->next();
+    }
+    m_pDS->close();
     sql = "DELETE FROM tvshow WHERE NOT EXISTS (SELECT 1 FROM tvshowlinkpath WHERE tvshowlinkpath.idShow = tvshow.idShow)";
     m_pDS->exec(sql.c_str());
 
@@ -7969,6 +8126,7 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     m_pDS->query(sql.c_str());
     while (!m_pDS->eof())
     {
+      cacheDeleteTvShowIds.insert(m_pDS->fv(0).get_asInt());
       tvshowIDs.push_back(m_pDS->fv(0).get_asInt());
       tvshowsToDelete += m_pDS->fv(0).get_asString() + ",";
       m_pDS->next();
@@ -8085,6 +8243,17 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     sql = "DELETE FROM sets WHERE NOT EXISTS (SELECT 1 FROM movie WHERE movie.idSet = sets.idSet)";
     m_pDS->exec(sql.c_str());
 
+    CLog::Log(LOGDEBUG, "%s: Updating cache items", __FUNCTION__);
+    for(std::set<int>::const_iterator it = cacheUpdateTvShowIds.begin(); it != cacheUpdateTvShowIds.end(); ++it) {
+      if(cacheDeleteTvShowIds.find(*it) == cacheDeleteTvShowIds.end())
+        UpdateTvShowFileItemById(*it);
+    }
+
+    CLog::Log(LOGDEBUG, "%s: Deleting cache items", __FUNCTION__);
+    for(std::set<int>::const_iterator it = cacheDeleteTvShowIds.begin(); it != cacheDeleteTvShowIds.end(); ++it) {
+      sm_TvShowCache.ProcessAffectedTvShowFileItems(*it, NULL, false, true);
+    }
+
     CommitTransaction();
 
     if (handle)
@@ -9179,6 +9348,8 @@ void CVideoDatabase::AnnounceRemove(std::string content, int id)
 
 void CVideoDatabase::AnnounceUpdate(std::string content, int id)
 {
+  CLog::Log(LOGDEBUG, "CVideoDatabase::AnnounceUpdate(%s, %d)", content, id);
+
   CVariant data;
   data["type"] = content;
   data["id"] = id;
@@ -9682,3 +9853,156 @@ bool CVideoDatabase::GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription
 
   return true;
 }
+
+//********************************************************************************************************************************
+// Tady je Bambiho
+
+void CVideoDatabase::UpdateTvShowFileItemById(int showId) {
+  try {
+    if(showId < 0) return;
+
+    unsigned int time = XbmcThreads::SystemClockMillis();
+    int fileItemCount = 0;
+
+    VEC_FILEITEMPTR affectedFileItems;
+    sm_TvShowCache.ProcessAffectedTvShowFileItems(showId, &affectedFileItems, false, false);
+
+    if(!affectedFileItems.empty()) {
+      if(NULL == m_pDB.get()) return;
+      if(NULL == m_pDS2.get()) return;
+
+      CStdString sql = PrepareSQL(
+          "SELECT strPath, dateAdded, lastPlayed, totalCount, watchedcount, totalSeasons FROM tvshowview WHERE idShow=%i", showId);
+
+      if(!m_pDS2->query(sql.c_str()))
+        return;
+
+      if(m_pDS2->num_rows() > 0) {
+        const dbiplus::sql_record* const record = m_pDS2->get_sql_record();
+
+        if(record != NULL) {
+          CStdString strPath = record->at(0).get_asString();
+          CStdString dateAdded = record->at(1).get_asString();
+          CStdString lastPlayed = record->at(2).get_asString();
+          int totalCount = record->at(3).get_asInt();
+          int watchedCount = record->at(4).get_asInt();
+          int totalSeasons = record->at(5).get_asInt();
+
+          for(VECI_FILEITEMPTR fileItemIter = affectedFileItems.begin(); fileItemIter != affectedFileItems.end(); fileItemIter++) {
+            CFileItemPtr fileItemPtr = *fileItemIter;
+
+            if(fileItemPtr->HasVideoInfoTag()) {
+              fileItemPtr->GetVideoInfoTag()->m_strPath = strPath;
+              fileItemPtr->GetVideoInfoTag()->m_dateAdded.SetFromDBDateTime(dateAdded);
+              fileItemPtr->GetVideoInfoTag()->m_lastPlayed.SetFromDBDateTime(lastPlayed);
+              fileItemPtr->GetVideoInfoTag()->m_iEpisode = totalCount;
+              fileItemPtr->GetVideoInfoTag()->m_playCount = watchedCount;
+              fileItemPtr->GetVideoInfoTag()->m_strShowPath = fileItemPtr->GetVideoInfoTag()->m_strPath;
+
+              fileItemPtr->SetProperty("totalseasons", totalSeasons);
+              fileItemPtr->SetProperty("totalepisodes", fileItemPtr->GetVideoInfoTag()->m_iEpisode);
+              fileItemPtr->SetProperty("numepisodes", fileItemPtr->GetVideoInfoTag()->m_iEpisode);
+              fileItemPtr->SetProperty("watchedepisodes", fileItemPtr->GetVideoInfoTag()->m_playCount);
+              fileItemPtr->SetProperty("unwatchedepisodes", fileItemPtr->GetVideoInfoTag()->m_iEpisode - fileItemPtr->GetVideoInfoTag()->m_playCount);
+
+              fileItemPtr->GetVideoInfoTag()->m_playCount =
+                  (fileItemPtr->GetVideoInfoTag()->m_iEpisode <= fileItemPtr->GetVideoInfoTag()->m_playCount) ? 1 : 0;
+
+              fileItemPtr->SetOverlayImage(
+                  CGUIListItem::ICON_OVERLAY_UNWATCHED,
+                  (fileItemPtr->GetVideoInfoTag()->m_playCount > 0) && (fileItemPtr->GetVideoInfoTag()->m_iEpisode > 0));
+
+              fileItemCount++;
+            }
+            else {
+              CLog::Log(LOGERROR, "FileItem %s has no VideoInfoTag", fileItemPtr->GetPath());
+            }
+          }
+        }
+      }
+
+      m_pDS2->close();
+    }
+
+    CLog::Log(LOGDEBUG, "%s took %d ms and updated %d FileItem(s)", __FUNCTION__, XbmcThreads::SystemClockMillis() - time, fileItemCount);
+  }
+  catch(...) {
+    CLog::Log(LOGERROR, "%s (%d) failed", __FUNCTION__, showId);
+  }
+}
+
+//********************************************************************************************************************************
+
+CTvShowCache CVideoDatabase::sm_TvShowCache;
+
+//********************************************************************************************************************************
+
+CTvShowCacheItem::CTvShowCacheItem(void) {
+  m_bIsDirty = false;
+}
+
+CTvShowCacheItem::~CTvShowCacheItem(void) {
+  m_fileItemListPtr->Clear();
+  m_tvShowId2FileItemPtr.clear();
+}
+
+//********************************************************************************************************************************
+
+CTvShowCache::CTvShowCache(void) {}
+
+CTvShowCache::~CTvShowCache(void) {
+  m_tvShowId2TvShowCacheItemPtrSet.clear();
+  m_sqlQuery2TvShowCacheItemPtr.clear();
+}
+
+void CTvShowCache::DirtyAllTvShowCacheItems() {
+  CLog::Log(LOGDEBUG, "%s marking all caced file lists dirty", __FUNCTION__);
+
+  for(MAPI_STRING2TVSHOWCACHEITEMPTR tvShowCacheItemPtrIter = m_sqlQuery2TvShowCacheItemPtr.begin();
+      tvShowCacheItemPtrIter != m_sqlQuery2TvShowCacheItemPtr.end(); tvShowCacheItemPtrIter++) {
+    tvShowCacheItemPtrIter->second->SetDirty(true);
+  }
+}
+
+void CTvShowCache::DirtyTvShowFileItemById(int showId) {
+  ProcessAffectedTvShowFileItems(showId, NULL, true, false);
+}
+
+void CTvShowCache::ProcessAffectedTvShowFileItems(int showId, VEC_FILEITEMPTR *affectedFileItems, bool dirty, bool remove) {
+  unsigned int time = XbmcThreads::SystemClockMillis();
+  MAPI_INT2TVSHOWCACHEITEMPTRSET tvShowId2TvShowCacheItemPtrSetIter = m_tvShowId2TvShowCacheItemPtrSet.find(showId);
+
+  if(tvShowId2TvShowCacheItemPtrSetIter != m_tvShowId2TvShowCacheItemPtrSet.end()) {
+    SET_TVSHOWCACHEITEMPTR tvShowCacheItemPtrSet = tvShowId2TvShowCacheItemPtrSetIter->second;
+
+    for(SETI_TVSHOWCACHEITEMPTR tvShowCacheSetIter = tvShowCacheItemPtrSet.begin();
+        tvShowCacheSetIter != tvShowCacheItemPtrSet.end(); tvShowCacheSetIter++) {
+      CTvShowCacheItemPtr tvShowCacheItemPtr(*tvShowCacheSetIter);
+      if(dirty)
+        tvShowCacheItemPtr->SetDirty(true);
+
+      MAPI_INT2FILEITEMPTR tvShowId2FileItemPtrIter = tvShowCacheItemPtr->m_tvShowId2FileItemPtr.find(showId);
+
+      if(tvShowId2FileItemPtrIter != tvShowCacheItemPtr->m_tvShowId2FileItemPtr.end()) {
+        CFileItemPtr cacheFileItemPtr = tvShowId2FileItemPtrIter->second;
+
+        CLog::Log(LOGDEBUG, "%s on %s", __FUNCTION__, cacheFileItemPtr->GetPath());
+
+        if(affectedFileItems)
+          affectedFileItems->push_back(cacheFileItemPtr);
+        if(dirty)
+          cacheFileItemPtr->SetDirty(true);
+        if(remove) {
+          tvShowCacheItemPtr->m_fileItemListPtr->Remove(cacheFileItemPtr.get());
+          tvShowCacheItemPtr->m_tvShowId2FileItemPtr.erase(showId);
+          // Decrese 'total' property? Looks like it isn't necessary
+        }
+      }
+    }
+
+    if(remove)
+      m_tvShowId2TvShowCacheItemPtrSet.erase(showId);
+  }
+
+  CLog::Log(LOGDEBUG, "%s took %d ms for showId %d", __FUNCTION__, XbmcThreads::SystemClockMillis() - time, showId);
+}
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 9f84b23..ff11cc0 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -24,6 +24,7 @@
 #include "Bookmark.h"
 #include "utils/SortUtils.h"
 #include "video/VideoDbUrl.h"
+#include "FileItem.h"
 
 #include <memory>
 #include <set>
@@ -331,6 +332,60 @@ const struct SDbTableOffsets DbMusicVideoOffsets[] =
 #define COMPARE_PERCENTAGE     0.90f // 90%
 #define COMPARE_PERCENTAGE_MIN 0.50f // 50%
 
+/* Tady je Bambiho */
+typedef boost::shared_ptr< CFileItemList > CFileItemListPtr;
+
+typedef std::map< int, CFileItemPtr > MAP_INT2FILEITEMPTR;
+typedef std::map< int, CFileItemPtr >::iterator MAPI_INT2FILEITEMPTR;
+typedef std::pair< int, CFileItemPtr > MAPP_INT2FILEITEMPTR;
+
+class CTvShowCacheItem {
+public:
+	CTvShowCacheItem();
+  virtual ~CTvShowCacheItem();
+
+  bool IsDirty() const { return m_bIsDirty; }
+  void SetDirty(bool isDirty) { m_bIsDirty = isDirty; }
+
+  CFileItemListPtr m_fileItemListPtr;
+  MAP_INT2FILEITEMPTR m_tvShowId2FileItemPtr;
+
+private:
+  bool m_bIsDirty;
+
+};
+
+typedef boost::shared_ptr< CTvShowCacheItem > CTvShowCacheItemPtr;
+
+typedef std::map< CStdString, CTvShowCacheItemPtr > MAP_STRING2TVSHOWCACHEITEMPTR;
+typedef std::map< CStdString, CTvShowCacheItemPtr >::iterator MAPI_STRING2TVSHOWCACHEITEMPTR;
+typedef std::pair< CStdString, CTvShowCacheItemPtr > MAPP_STRING2TVSHOWCACHEITEMPTR;
+
+typedef std::set< CTvShowCacheItemPtr > SET_TVSHOWCACHEITEMPTR;
+typedef std::set< CTvShowCacheItemPtr >::iterator SETI_TVSHOWCACHEITEMPTR;
+
+typedef std::vector< CFileItemPtr > VEC_FILEITEMPTR;
+typedef std::vector< CFileItemPtr >::iterator VECI_FILEITEMPTR;
+
+typedef std::map< int, SET_TVSHOWCACHEITEMPTR > MAP_INT2TVSHOWCACHEITEMPTRSET;
+typedef std::map< int, SET_TVSHOWCACHEITEMPTR >::iterator MAPI_INT2TVSHOWCACHEITEMPTRSET;
+typedef std::pair< int, SET_TVSHOWCACHEITEMPTR > MAPP_INT2TVSHOWCACHEITEMPTRSET;
+
+class CTvShowCache {
+public:
+	CTvShowCache();
+  virtual ~CTvShowCache();
+
+  void ProcessAffectedTvShowFileItems(int showId, VEC_FILEITEMPTR *affectedFileItems, bool dirty, bool remove);
+  void DirtyTvShowFileItemById(int showId);
+
+  void DirtyAllTvShowCacheItems();
+
+  MAP_STRING2TVSHOWCACHEITEMPTR m_sqlQuery2TvShowCacheItemPtr;
+  MAP_INT2TVSHOWCACHEITEMPTRSET m_tvShowId2TvShowCacheItemPtrSet;
+
+};
+
 class CVideoDatabase : public CDatabase
 {
 public:
@@ -464,7 +519,7 @@ public:
   void DeleteTvShow(int idTvShow, bool bKeepId = false);
   void DeleteTvShow(const CStdString& strPath, bool bKeepId = false, int idTvShow = -1);
   void DeleteEpisode(int idEpisode, bool bKeepId = false);
-  void DeleteEpisode(const CStdString& strFilenameAndPath, int idEpisode = -1, bool bKeepId = false);
+  void DeleteEpisode(const CStdString& strFilenameAndPath, int idEpisode = -1, bool bKeepId = false, bool bUpdateCache = true);
   void DeleteMusicVideo(int idMusicVideo, bool bKeepId = false);
   void DeleteMusicVideo(const CStdString& strFilenameAndPath, bool bKeepId = false, int idMVideo = -1);
   void DeleteDetailsForTvShow(const CStdString& strPath, int idTvShow = -1);
@@ -831,4 +886,8 @@ private:
 
   void AnnounceRemove(std::string content, int id);
   void AnnounceUpdate(std::string content, int id);
+
+  void UpdateTvShowFileItemById(int showId);
+
+  static CTvShowCache sm_TvShowCache;
 };
diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index 9bbd897..ba653d3 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -1765,7 +1765,7 @@ bool CGUIWindowVideoBase::StackingAvailable(const CFileItemList &items)
            url.GetProtocol() == "playlistvideo");
 }
 
-void CGUIWindowVideoBase::GetGroupedItems(CFileItemList &items)
+void CGUIWindowVideoBase::GetGroupedItems(CFileItemList &items, int startIndex /* = 0 */)
 {
   CGUIMediaWindow::GetGroupedItems(items);
 
@@ -1800,7 +1800,7 @@ void CGUIWindowVideoBase::GetGroupedItems(CFileItemList &items)
   if (m_thumbLoader.IsLoading())
     m_thumbLoader.StopThread();
 
-  m_thumbLoader.Load(items);
+  m_thumbLoader.Load(items, startIndex);
 }
 
 bool CGUIWindowVideoBase::CheckFilterAdvanced(CFileItemList &items) const
diff --git a/xbmc/video/windows/GUIWindowVideoBase.h b/xbmc/video/windows/GUIWindowVideoBase.h
index 1559934..dc8788d 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.h
+++ b/xbmc/video/windows/GUIWindowVideoBase.h
@@ -96,7 +96,7 @@ protected:
   virtual bool Update(const CStdString &strDirectory, bool updateFilterPath = true);
   virtual bool GetDirectory(const CStdString &strDirectory, CFileItemList &items);
   virtual void OnItemLoaded(CFileItem* pItem) {};
-  virtual void GetGroupedItems(CFileItemList &items);
+  virtual void GetGroupedItems(CFileItemList &items, int startIndex = 0);
 
   virtual bool CheckFilterAdvanced(CFileItemList &items) const;
   virtual bool CanContainFilter(const CStdString &strDirectory) const;
diff --git a/xbmc/video/windows/GUIWindowVideoNav.cpp b/xbmc/video/windows/GUIWindowVideoNav.cpp
index 60f3ad35..762b9ec 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.cpp
+++ b/xbmc/video/windows/GUIWindowVideoNav.cpp
@@ -269,6 +269,9 @@ CStdString CGUIWindowVideoNav::GetQuickpathName(const CStdString& strPath) const
 
 bool CGUIWindowVideoNav::GetDirectory(const CStdString &strDirectory, CFileItemList &items)
 {
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s started", __FUNCTION__);
+
   if (m_thumbLoader.IsLoading())
     m_thumbLoader.StopThread();
 
@@ -428,6 +431,9 @@ bool CGUIWindowVideoNav::GetDirectory(const CStdString &strDirectory, CFileItemL
       items.Add(newTag);
     }
   }
+
+  CLog::Log(LOGDEBUG, "%s took %d ms ", __FUNCTION__, XbmcThreads::SystemClockMillis() - timeFull);
+
   return bResult;
 }
 
@@ -584,9 +590,13 @@ void CGUIWindowVideoNav::UpdateButtons()
 
 bool CGUIWindowVideoNav::GetFilteredItems(const CStdString &filter, CFileItemList &items)
 {
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+
   bool listchanged = CGUIMediaWindow::GetFilteredItems(filter, items);
   listchanged |= ApplyWatchedFilter(items);
 
+  CLog::Log(LOGDEBUG, "%s took %d ms", __FUNCTION__, XbmcThreads::SystemClockMillis() - timeFull);
+
   return listchanged;
 }
 
@@ -1206,8 +1216,16 @@ bool CGUIWindowVideoNav::ApplyWatchedFilter(CFileItemList &items)
     // the watched filter may change the "numepisodes" property which is reflected in the TV_SHOWS and SEASONS nodes
     // therefore, the items labels have to be refreshed, and possibly the list needs resorting as well.
     items.ClearSortState(); // this is needed to force resorting even if sort method did not change
-    FormatAndSort(items);
   }
 
   return listchanged;
 }
+
+//void CGUIWindowVideoNav::GetDirectoryHistoryString(const CFileItem* pItem, CStdString& strHistoryString) {
+//  if (pItem->m_bIsShareOrDrive || (pItem->m_lEndOffset>pItem->m_lStartOffset && pItem->m_lStartOffset != -1) || !pItem->HasVideoInfoTag()) {
+//    CGUIMediaWindow::GetDirectoryHistoryString(pItem, strHistoryString);
+//  }
+//  else {
+//    strHistoryString = StringUtils::Format("%d",pItem->GetVideoInfoTag()->m_iDbId);
+//  }
+//}
diff --git a/xbmc/windows/GUIMediaWindow.cpp b/xbmc/windows/GUIMediaWindow.cpp
index 3404f99..ab728d7 100644
--- a/xbmc/windows/GUIMediaWindow.cpp
+++ b/xbmc/windows/GUIMediaWindow.cpp
@@ -234,6 +234,11 @@ bool CGUIMediaWindow::OnMessage(CGUIMessage& message)
     {
       m_iSelectedItem = m_viewControl.GetSelectedItem();
       m_iLastControl = GetFocusedControlID();
+
+      CStdString selectedItemIdent;
+      GetSelectedItemIdent(selectedItemIdent);
+      m_history.SetSelectedItem(selectedItemIdent, m_vecItems->GetPath());
+
       CGUIWindow::OnMessage(message);
       CGUIDialogContextMenu* pDlg = (CGUIDialogContextMenu*)g_windowManager.GetWindow(WINDOW_DIALOG_CONTEXT_MENU);
       if (pDlg && pDlg->IsActive())
@@ -626,6 +631,8 @@ void CGUIMediaWindow::FormatItemLabels(CFileItemList &items, const LABEL_MASKS &
 // \brief Prepares and adds the fileitems list/thumb panel
 void CGUIMediaWindow::FormatAndSort(CFileItemList &items)
 {
+  unsigned int timePart = XbmcThreads::SystemClockMillis();
+
   auto_ptr<CGUIViewState> viewState(CGUIViewState::GetViewState(GetID(), items));
 
   if (viewState.get())
@@ -634,7 +641,13 @@ void CGUIMediaWindow::FormatAndSort(CFileItemList &items)
     viewState->GetSortMethodLabelMasks(labelMasks);
     FormatItemLabels(items, labelMasks);
 
+    CLog::Log(LOGDEBUG, "%s: %s took %d ms", __FUNCTION__, "FormatItemLabels", XbmcThreads::SystemClockMillis() - timePart);
+    timePart = XbmcThreads::SystemClockMillis();
+
     items.Sort(viewState->GetSortMethod().sortBy, viewState->GetDisplaySortOrder(), viewState->GetSortMethod().sortAttributes);
+
+    CLog::Log(LOGDEBUG, "%s: %s took %d ms", __FUNCTION__, "Sort", XbmcThreads::SystemClockMillis() - timePart);
+    timePart = XbmcThreads::SystemClockMillis();
   }
 }
 
@@ -645,6 +658,9 @@ void CGUIMediaWindow::FormatAndSort(CFileItemList &items)
   */
 bool CGUIMediaWindow::GetDirectory(const CStdString &strDirectory, CFileItemList &items)
 {
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+ 	CLog::Log(LOGDEBUG, "%s started", __FUNCTION__);
+
   // cleanup items
   if (items.Size())
     items.Clear();
@@ -664,6 +680,7 @@ bool CGUIMediaWindow::GetDirectory(const CStdString &strDirectory, CFileItemList
   else
   {
     unsigned int time = XbmcThreads::SystemClockMillis();
+    unsigned int timePart = XbmcThreads::SystemClockMillis();
 
     if (strDirectory.empty())
       SetupShares();
@@ -672,7 +689,7 @@ bool CGUIMediaWindow::GetDirectory(const CStdString &strDirectory, CFileItemList
       return false;
 
     // took over a second, and not normally cached, so cache it
-    if ((XbmcThreads::SystemClockMillis() - time) > 1000  && items.CacheToDiscIfSlow())
+    if ((XbmcThreads::SystemClockMillis() - time) > 1000  && items.CacheToDiscIfSlow() && false)
       items.Save(GetID());
 
     // if these items should replace the current listing, then pop it off the top
@@ -715,6 +732,9 @@ bool CGUIMediaWindow::GetDirectory(const CStdString &strDirectory, CFileItemList
   SetProperty("filter", "");
   m_canFilterAdvanced = false;
   m_filter.Reset();
+
+  CLog::Log(LOGDEBUG, "%s took %d ms ", __FUNCTION__, XbmcThreads::SystemClockMillis() - timeFull);
+
   return true;
 }
 
@@ -723,22 +743,16 @@ bool CGUIMediaWindow::GetDirectory(const CStdString &strDirectory, CFileItemList
 // This function calls OnPrepareFileItems() and OnFinalizeFileItems()
 bool CGUIMediaWindow::Update(const CStdString &strDirectory, bool updateFilterPath /* = true */)
 {
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+	CLog::Log(LOGDEBUG, "%s started", __FUNCTION__);
+
   // TODO: OnInitWindow calls Update() before window path has been set properly.
   if (strDirectory == "?")
     return false;
 
-  // get selected item
-  int iItem = m_viewControl.GetSelectedItem();
-  CStdString strSelectedItem = "";
-  if (iItem >= 0 && iItem < m_vecItems->Size())
-  {
-    CFileItemPtr pItem = m_vecItems->Get(iItem);
-    if (!pItem->IsParentFolder())
-    {
-      GetDirectoryHistoryString(pItem.get(), strSelectedItem);
-    }
-  }
-  
+  CStdString strSelectedItem;
+  GetSelectedItemIdent(strSelectedItem);
+
   CStdString strCurrentDirectory = m_vecItems->GetPath();
   m_history.SetSelectedItem(strSelectedItem, strCurrentDirectory);
 
@@ -768,12 +782,16 @@ bool CGUIMediaWindow::Update(const CStdString &strDirectory, bool updateFilterPa
   if (items.GetLabel().empty())
     items.SetLabel(CUtil::GetTitleFromPath(items.GetPath(), true));
   
+  unsigned int timePart = XbmcThreads::SystemClockMillis();
+
   ClearFileItems();
   m_vecItems->Copy(items);
 
+  CLog::Log(LOGDEBUG, "%s: items copy took %d ms", __FUNCTION__, XbmcThreads::SystemClockMillis() - timePart);
+
   // check the given path for filter data
   UpdateFilterPath(strDirectory, items, updateFilterPath);
-    
+
   // if we're getting the root source listing
   // make sure the path history is clean
   if (strDirectory.empty())
@@ -834,8 +852,10 @@ bool CGUIMediaWindow::Update(const CStdString &strDirectory, bool updateFilterPa
   // Cache the list of items if possible
   OnCacheFileItems(*m_vecItems);
 
+//  CLog::Log(LOGDEBUG, "%s: m_vecItems->GetPath() = %s", __FUNCTION__, m_vecItems->GetPath().c_str());
+
   // Filter and group the items if necessary
-  OnFilterItems(GetProperty("filter").asString());
+  OnFilterItems(GetProperty("filter").asString(), true);
 
   // Ask the devived class if it wants to do custom list operations,
   // eg. changing the label
@@ -843,27 +863,10 @@ bool CGUIMediaWindow::Update(const CStdString &strDirectory, bool updateFilterPa
   UpdateButtons();
 
   strSelectedItem = m_history.GetSelectedItem(m_vecItems->GetPath());
-
-  bool bSelectedFound = false;
-  //int iSongInDirectory = -1;
-  for (int i = 0; i < m_vecItems->Size(); ++i)
-  {
-    CFileItemPtr pItem = m_vecItems->Get(i);
-
-    // Update selected item
-    CStdString strHistory;
-    GetDirectoryHistoryString(pItem.get(), strHistory);
-    if (strHistory == strSelectedItem)
-    {
-      m_viewControl.SetSelectedItem(i);
-      bSelectedFound = true;
-      break;
-    }
-  }
+  int selectedItemIndex = GetItemIndexByIndent(strSelectedItem);
 
   // if we haven't found the selected item, select the first item
-  if (!bSelectedFound)
-    m_viewControl.SetSelectedItem(0);
+  m_viewControl.SetSelectedItem(selectedItemIndex >= 0 ? selectedItemIndex : 0);
 
   if (iWindow != WINDOW_PVR ||
       (iWindow == WINDOW_PVR && StringUtils::StartsWith(m_vecItems->GetPath(), "pvr://recordings/")))
@@ -871,11 +874,16 @@ bool CGUIMediaWindow::Update(const CStdString &strDirectory, bool updateFilterPa
 
   //m_history.DumpPathHistory();
 
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "CGUIMediaWindow::Update", XbmcThreads::SystemClockMillis() - timeFull);
+
   return true;
 }
 
 bool CGUIMediaWindow::Refresh(bool clearCache /* = false */)
 {
+  unsigned int time = XbmcThreads::SystemClockMillis();
+	CLog::Log(LOGDEBUG, "%s(%s) started", __FUNCTION__, clearCache ? "true" : "false");
+
   CStdString strCurrentDirectory = m_vecItems->GetPath();
   if (strCurrentDirectory.Equals("?"))
     return false;
@@ -884,8 +892,12 @@ bool CGUIMediaWindow::Refresh(bool clearCache /* = false */)
     m_vecItems->RemoveDiscCache(GetID());
 
   // get the original number of items
-  if (!Update(strCurrentDirectory, false))
+  if (!Update(strCurrentDirectory, false)) {
+    CLog::Log(LOGDEBUG, "%s took %d ms ", __FUNCTION__, XbmcThreads::SystemClockMillis() - time);
     return false;
+  }
+
+  CLog::Log(LOGDEBUG, "%s took %d ms ", __FUNCTION__, XbmcThreads::SystemClockMillis() - time);
 
   return true;
 }
@@ -896,7 +908,7 @@ bool CGUIMediaWindow::Refresh(bool clearCache /* = false */)
 // It's used to load tag info for music.
 void CGUIMediaWindow::OnPrepareFileItems(CFileItemList &items)
 {
-  CFileItemListModification::Get().Modify(items);
+	CFileItemListModification::Get().Modify(items);
 }
 
 // \brief This function will be called by Update() before
@@ -904,7 +916,7 @@ void CGUIMediaWindow::OnPrepareFileItems(CFileItemList &items)
 // Override this function to define a custom caching behaviour.
 void CGUIMediaWindow::OnCacheFileItems(CFileItemList &items)
 {
-  // Should these items be saved to the hdd
+	// Should these items be saved to the hdd
   if (items.CacheToDiscAlways() && !IsFiltered())
     items.Save(GetID());
 }
@@ -1229,6 +1241,11 @@ void CGUIMediaWindow::GetDirectoryHistoryString(const CFileItem* pItem, CStdStri
                                            pItem->m_lEndOffset);
     strHistoryString += pItem->GetPath();
   }
+  else if(pItem->HasVideoInfoTag())
+  {
+    strHistoryString = strHistoryString = StringUtils::Format("%d",pItem->GetVideoInfoTag()->m_iDbId);
+    return;
+  }
   else
   {
     // Normal directory items
@@ -1394,16 +1411,19 @@ bool CGUIMediaWindow::OnPlayAndQueueMedia(const CFileItemPtr &item)
 // on the fileitems of the window
 void CGUIMediaWindow::UpdateFileList()
 {
-  int nItem = m_viewControl.GetSelectedItem();
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+	CLog::Log(LOGDEBUG, "%s started", __FUNCTION__);
+
   CStdString strSelected;
-  if (nItem >= 0)
-    strSelected = m_vecItems->Get(nItem)->GetPath();
+  GetSelectedItemIdent(strSelected);
 
   FormatAndSort(*m_vecItems);
   UpdateButtons();
 
   m_viewControl.SetItems(*m_vecItems);
-  m_viewControl.SetSelectedItem(strSelected);
+
+  int selectedItemIndex = GetItemIndexByIndent(strSelected);
+  m_viewControl.SetSelectedItem(selectedItemIndex >= 0 ? selectedItemIndex : 0);
 
   //  set the currently playing item as selected, if its in this directory
   if (m_guiState.get() && m_guiState->IsCurrentPlaylistDirectory(m_vecItems->GetPath()))
@@ -1431,6 +1451,8 @@ void CGUIMediaWindow::UpdateFileList()
         g_playlistPlayer.SetCurrentSong(g_playlistPlayer.GetPlaylist(iPlaylist).size() - 1);
     }
   }
+
+  CLog::Log(LOGDEBUG, "%s finished in %d ms", __FUNCTION__, XbmcThreads::SystemClockMillis() - timeFull);
 }
 
 void CGUIMediaWindow::OnDeleteItem(int iItem)
@@ -1467,7 +1489,10 @@ void CGUIMediaWindow::OnRenameItem(int iItem)
 
 void CGUIMediaWindow::OnInitWindow()
 {
-  // initial fetch is done unthreaded to ensure the items are setup prior to skin animations kicking off
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s started", __FUNCTION__);
+
+	// initial fetch is done unthreaded to ensure the items are setup prior to skin animations kicking off
   m_rootDir.SetAllowThreads(false);
 
   // the start directory may change during Refresh
@@ -1478,10 +1503,18 @@ void CGUIMediaWindow::OnInitWindow()
 
   m_rootDir.SetAllowThreads(true);
 
-  if (m_iSelectedItem > -1)
-    m_viewControl.SetSelectedItem(m_iSelectedItem);
+  int selectedItemIndex = m_viewControl.GetSelectedItem();
+  int currentControlId = m_viewControl.GetCurrentControl();
+
+  for(vector<CControlState>::iterator it = m_controlStates.begin(); it != m_controlStates.end(); ++it) {
+    CControlState *controlStatePtr = &(*it);
+    if(controlStatePtr->m_id == currentControlId)
+      controlStatePtr->m_data = selectedItemIndex;
+  }
 
   CGUIWindow::OnInitWindow();
+
+  CLog::Log(LOGDEBUG, "%s took %d ms", __FUNCTION__, XbmcThreads::SystemClockMillis() - timeFull);
 }
 
 CGUIControl *CGUIMediaWindow::GetFirstFocusableControl(int id)
@@ -1708,17 +1741,18 @@ void CGUIMediaWindow::UpdateFilterPath(const CStdString &strDirectory, const CFi
   }
 }
 
-void CGUIMediaWindow::OnFilterItems(const CStdString &filter)
+void CGUIMediaWindow::OnFilterItems(const CStdString &filter, const bool onUpdate)
 {
-  CFileItemPtr currentItem;
-  CStdString currentItemPath;
-  int item = m_viewControl.GetSelectedItem();
-  if (item >= 0 && item < m_vecItems->Size())
-  {
-    currentItem = m_vecItems->Get(item);
-    currentItemPath = currentItem->GetPath();
-  }
-  
+  unsigned int timeFull = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s(%s) started", __FUNCTION__, (onUpdate ? "true" : "false"));
+
+  CStdString selectedItemIdent;
+
+  if(onUpdate)
+    selectedItemIdent = m_history.GetSelectedItem(m_vecItems->GetPath());
+  else
+    GetSelectedItemIdent(selectedItemIdent);
+
   m_viewControl.Clear();
   
   CFileItemList items;
@@ -1744,7 +1778,7 @@ void CGUIMediaWindow::OnFilterItems(const CStdString &filter)
       m_strFilterPath = items.GetPath();
   }
   
-  GetGroupedItems(*m_vecItems);
+  GetGroupedItems(*m_vecItems, GetItemIndexByIndent(selectedItemIdent));
   FormatAndSort(*m_vecItems);
 
   // get the "filter" option
@@ -1753,41 +1787,7 @@ void CGUIMediaWindow::OnFilterItems(const CStdString &filter)
   if (filterUrl.HasOption("filter"))
     filterOption = filterUrl.GetOption("filter");
 
-  // apply the "filter" option to any folder item so that
-  // the filter can be passed down to the sub-directory
-  for (int index = 0; index < m_vecItems->Size(); index++)
-  {
-    CFileItemPtr pItem = m_vecItems->Get(index);
-    // if the item is a folder we need to copy the path of
-    // the filtered item to be able to keep the applied filters
-    if (pItem->m_bIsFolder)
-    {
-      CURL itemUrl(pItem->GetPath());
-      if (!filterOption.empty())
-        itemUrl.SetOption("filter", filterOption);
-      else
-        itemUrl.RemoveOption("filter");
-      pItem->SetPath(itemUrl.Get());
-    }
-  }
-
   SetProperty("filter", filter);
-  if (filtered && m_canFilterAdvanced)
-  {
-    // to be able to select the same item as before we need to adjust
-    // the path of the item i.e. add or remove the "filter=" URL option
-    // but that's only necessary for folder items
-    if (currentItem.get() != NULL && currentItem->m_bIsFolder)
-    {
-      CURL curUrl(currentItemPath), newUrl(m_strFilterPath);
-      if (newUrl.HasOption("filter"))
-        curUrl.SetOption("filter", newUrl.GetOption("filter"));
-      else if (curUrl.HasOption("filter"))
-        curUrl.RemoveOption("filter");
-
-      currentItemPath = curUrl.Get();
-    }
-  }
 
   // The idea here is to ensure we have something to focus if our file list
   // is empty.  As such, this check MUST be last and ignore the hide parent
@@ -1803,8 +1803,13 @@ void CGUIMediaWindow::OnFilterItems(const CStdString &filter)
 
   // and update our view control + buttons
   m_viewControl.SetItems(*m_vecItems);
-  m_viewControl.SetSelectedItem(currentItemPath);
+
+  if(!onUpdate)
+    m_viewControl.SetSelectedItem(GetItemIndexByIndent(selectedItemIdent));
+
   UpdateButtons();
+
+  CLog::Log(LOGDEBUG, "%s took %d ms ", "CGUIMediaWindow::OnFilterItems", XbmcThreads::SystemClockMillis() - timeFull);
 }
 
 bool CGUIMediaWindow::GetFilteredItems(const CStdString &filter, CFileItemList &items)
@@ -1973,3 +1978,28 @@ CStdString CGUIMediaWindow::RemoveParameterFromPath(const CStdString &strDirecto
 
   return strDirectory;
 }
+
+void CGUIMediaWindow::GetSelectedItemIdent(CStdString &selectedItemIdent) {
+  int selectedItemIndex = m_viewControl.GetSelectedItem();
+
+  if (selectedItemIndex >= 0 && selectedItemIndex < m_vecItems->Size()) {
+    CFileItemPtr pItem = m_vecItems->Get(selectedItemIndex);
+    if(!pItem->IsParentFolder())
+      GetDirectoryHistoryString(pItem.get(), selectedItemIdent);
+  }
+}
+
+int CGUIMediaWindow::GetItemIndexByIndent(CStdString &itemIdent) {
+  if(!itemIdent.empty()) {
+    CStdString currentItemIdent;
+
+    for(int i = 0; i < m_vecItems->Size(); ++i) {
+      GetDirectoryHistoryString(m_vecItems->Get(i).get(), currentItemIdent);
+      if(currentItemIdent == itemIdent)
+        return i;
+    }
+  }
+
+  return -1;
+}
+
diff --git a/xbmc/windows/GUIMediaWindow.h b/xbmc/windows/GUIMediaWindow.h
index b4d73ee..41ccaa8 100644
--- a/xbmc/windows/GUIMediaWindow.h
+++ b/xbmc/windows/GUIMediaWindow.h
@@ -89,7 +89,7 @@ protected:
   virtual void OnPrepareFileItems(CFileItemList &items);
   virtual void OnCacheFileItems(CFileItemList &items);
   virtual void OnFinalizeFileItems(CFileItemList &items);
-  virtual void GetGroupedItems(CFileItemList &items) { }
+  virtual void GetGroupedItems(CFileItemList &items, int startIndex = 0) { }
 
   void ClearFileItems();
   virtual void SortItems(CFileItemList &items);
@@ -112,7 +112,7 @@ protected:
    \param filter the filter to use.
    \sa FilterItems
    */
-  void OnFilterItems(const CStdString &filter);
+  virtual void OnFilterItems(const CStdString &filter, const bool onUpdate = false);
 
   /* \brief Retrieve the filtered item list
    \param filter filter to apply
@@ -133,12 +133,12 @@ protected:
   virtual bool HaveDiscOrConnection(const CStdString& strPath, int iDriveType);
   void ShowShareErrorMessage(CFileItem* pItem);
 
-  void GetDirectoryHistoryString(const CFileItem* pItem, CStdString& strHistoryString);
+  virtual void GetDirectoryHistoryString(const CFileItem* pItem, CStdString& strHistoryString);
   void SetHistoryForPath(const CStdString& strDirectory);
   virtual void LoadPlayList(const CStdString& strFileName) {}
   virtual bool OnPlayMedia(int iItem);
   virtual bool OnPlayAndQueueMedia(const CFileItemPtr &item);
-  void UpdateFileList();
+  virtual void UpdateFileList();
   virtual void OnDeleteItem(int iItem);
   void OnRenameItem(int iItem);
 
@@ -150,6 +150,9 @@ protected:
    \return the resulting path */
   virtual CStdString GetStartFolder(const CStdString &url);
 
+  virtual void GetSelectedItemIdent(CStdString &selectedItemIdent);
+  virtual int  GetItemIndexByIndent(CStdString &itemIdent);
+
   /*! \brief Utility method to remove the given parameter from a path/URL
    \param strDirectory Path/URL from which to remove the given parameter
    \param strParameter Parameter to remove from the given path/URL
